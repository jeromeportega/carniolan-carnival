// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information

//Spawns a bullet at player position and sets its speed an direction
function shoot(spd, dir) {
	var bullet = instance_create_layer(x, y, "Instances", Bullet);
	with (bullet) {
		speed = spd; //set its new speed
		direction = dir; //new direction
		image_angle = dir; //make bullet face forward
	}
}

//Checks ifa bullet should be fired, if so fires and resets cooldown otherwise decrements cooldown
function handlePlayerShooting(spd, dir) {
	if (shootCD == 0) {
		shoot(spd, dir);
		shootCD = FIRERATE/(global.pace/global.MINPACE);
	}
	else {
		shootCD = max(0, shootCD-1);
	}
}

//Snaps player to x boundaries if it moves outside its allowed values
function boundPlayerWithinBuffer() {
	if (x < global.HORIZONTAL_BUFFER) x = global.HORIZONTAL_BUFFER;
	else if (x > room_width - global.HORIZONTAL_BUFFER) x = room_width - global.HORIZONTAL_BUFFER;
}

//Computes a value from a composite wave function, generated by several randomly generated waves.
function getRandomAmplitude(time) {
	var sum = 0;
	//Loop through our list of coefficients to sum their outputs
	for (var i = 0; i < ds_list_size(oscilateCoeffs); i++) {
		if (i % 2 == 0) sum += ds_list_find_value(oscilateCoeffs, i) * dsin((time * ds_list_find_value(oscilateFreqs, i)) + ds_list_find_value(oscilatePhases, i));
		//Switching to cos is not strictly necessary however it does ensure they will be out of phase if no phase value is set
		else sum += ds_list_find_value(oscilateCoeffs, i) * dcos((time * ds_list_find_value(oscilateFreqs, i)) + ds_list_find_value(oscilatePhases, i));
	}
	
	return sum;
}

//Calls the appropriate shader config for player state
function configurePlayerShader() {
	if (playerState == playerStates.respawning)
	{
		shader_set(respawnBlink); //Set the shader
		var shader_params = shader_get_uniform(respawnBlink, "mask"); //Get the mask uniform handle
		//Compute what alpha should be for where we are in the given state
		var a = (dsin((flashFrequency*flashDamping*global.respawnTIME/((flashDamping+1+flashBias)*global.respawnTIME - stateDuration))*(2*global.FRAMERATE - stateDuration))+1)/2;
		shader_set_uniform_f(shader_params, a); //Pass the aplha value into the shader
	}
	else if (playerState == playerStates.invincible)
	{
		shader_set(invinceBlink);//Set the shader
		var shader_params = shader_get_uniform(respawnBlink, "mask"); //Get the mask uniform handle
		//Compute what alpha should be for where we are in the given state
		var a = (dsin((invFlashFrequency*invFlashDamping*global.invincibleTIME/((invFlashDamping+1+invFlashBias)*global.invincibleTIME - stateDuration))*(2*global.FRAMERATE - stateDuration))+1)/2;
		shader_set_uniform_f(shader_params, a); //Pass the aplha value into the shader
	}
	else shader_reset(); //Clears current shader just in case
}

//Sets Hspeed to move player towards where the current targetX is
function handlePlayerMovement() {
	//Sets hspeed up to maxHSpeed but scales it smaller to slow movement as we get close to targetX
	hspeed = sign(targetX - x)*maxHSpeed*(global.pace/global.MINPACE)*(min(room_width/20, abs(targetX - x))/(room_width/20));
	
	//If we would move past targetX with current hspeed, set hspeed to hit target X exactly
	//this prevents oscilations around targetX
	if (abs(hspeed) > abs(targetX - x)) hspeed = sign(hspeed)*abs(targetX - x);
}